// Copyright 2019 Tricot Inc.
// Use of this source code is governed by the license in the LICENSE file.

// Command bazel2cmake converts Bazel BUILD files to CMake CMakeLists.txt files.
package main

import (
	"flag"
	"fmt"
	"io"
	"os"
	"path/filepath"
	"strings"

	"bazel2cmake/bazel"
	"bazel2cmake/bazel/builtins/rules"
	"bazel2cmake/bazel/core"
	"bazel2cmake/bazel/utils"
)

var onlyPrintTargetsFlag = flag.Bool("only-print-targets", false, "print targets and exit")
var outDirFlag = flag.String("out-dir", "", "(root) output directory")

func printTargets(build *bazel.Build) {
	for workspaceName, workspaceTargets := range build.BuildTargets {
		fmt.Printf("Workspace @%v\n", string(workspaceName))
		for packageName, packageTargets := range workspaceTargets {
			fmt.Printf("  Package %v\n", packageName)
			for _, target := range packageTargets.TargetList {
				fmt.Printf("    Target %v\n", target.Label().Target)
				fmt.Printf("      %v\n", target)
			}
		}
	}
}

func toDashes(s string) string {
	return strings.ReplaceAll(s, "/", "-")
}

func dashJoin(parts ...string) string {
	return strings.Join(parts, "-")
}

type CmakeConverter struct {
	// MinimumVersion is the minimum CMake version (e.g., "3.10.0").
	MinimumVersion string

	// ProjectPrefix is the prefix to prepend (not including separating '-') to all project
	// names (it is also the name of the root project). If empty, the workspace name will be
	// used.
	ProjectPrefix string

	// CcLibraryName is the CMake name to use for cc_library targets. If empty,
	// "bazel2cmake_cc_library" will be used.
	CcLibraryName string

	// CcBinaryName is the CMake name to use for cc_binary targets. If empty,
	// "bazel2cmake_cc_binary" will be used.
	CcBinaryName string

	// CcTestName is the CMake name to use for cc_test targets. If empty, "bazel2cmake_cc_test"
	// will be used.
	CcTestName string

	// Includes are the includes for CMakeLists.txt files. If nil, "Bazel2cmakeSupport" will be
	// included.
	Includes []string

	build         *bazel.Build
}

func (self *CmakeConverter) Init(build *bazel.Build) error {
	self.build = build
	if self.ProjectPrefix == "" {
		self.ProjectPrefix = string(build.WorkspaceName)
	}
	if self.CcLibraryName == "" {
		self.CcLibraryName = "bazel2cmake_cc_library"
	}
	if self.CcBinaryName == "" {
		self.CcBinaryName = "bazel2cmake_cc_binary"
	}
	if self.CcTestName == "" {
		self.CcTestName = "bazel2cmake_cc_test"
	}
	if self.Includes == nil {
		self.Includes = []string{"Bazel2cmakeSupport"}
	}
	return nil
}

func (self *CmakeConverter) targetName(l core.Label) string {
	if !l.IsExternal() {
		return dashJoin(self.ProjectPrefix, toDashes(string(l.Package)),
			toDashes(string(l.Target)))
	} else {
		return fmt.Sprintf("# TODO (external dep): %v", l)
	}
}

func (self *CmakeConverter) writeNonRootHeader(packageName core.PackageName, w io.Writer) error {
	if _, err := fmt.Fprintf(w, "# Code generated by bazel2cmake. DO NOT EDIT.\n"); err != nil {
		return err
	}

	if _, err := fmt.Fprintf(w, "\ncmake_minimum_required(VERSION %v)\n",
		self.MinimumVersion); err != nil {
		return err
	}

	if len(self.Includes) > 0 {
		if _, err := fmt.Fprintf(w, "\n"); err != nil {
			return err
		}
		for _, inc := range self.Includes {
			if _, err := fmt.Fprintf(w, "include(%v)\n", inc); err != nil {
				return err
			}
		}
	}

	projectName := dashJoin(self.ProjectPrefix, toDashes(string(packageName)))
	if _, err := fmt.Fprintf(w, "\nproject(%v LANGUAGES CXX)\n", projectName); err != nil {
		return err
	}

	return nil
}

func (self *CmakeConverter) writeNonRootBody(targetName core.TargetName, target core.Target,
	w io.Writer) error {

	switch target.(type) {
	case *rules.CcLibraryTarget:
		t := target.(*rules.CcLibraryTarget)

		if _, err := fmt.Fprintf(w, "\n%v(\n", self.CcLibraryName); err != nil {
			return err
		}

		if _, err := fmt.Fprintf(w, "    %v\n",
			self.targetName(target.Label())); err != nil {
			return err
		}

		if t.Srcs != nil {
			if _, err := fmt.Fprintf(w, "    SRCS\n"); err != nil {
				return err
			}
			for _, l := range *t.Srcs {
				// Assume that it's just a simple filename, so just use the target
				// part of the label.
				if _, err := fmt.Fprintf(w, "        %v\n",
					string(l.Target)); err != nil {
					return err
				}
			}
		}

		if t.Hdrs != nil {
			if _, err := fmt.Fprintf(w, "    HDRS\n"); err != nil {
				return err
			}
			for _, l := range *t.Hdrs {
				// Assume that it's just a simple filename, so just use the target
				// part of the label.
				if _, err := fmt.Fprintf(w, "        %v\n",
					string(l.Target)); err != nil {
					return err
				}
			}
		}

		if t.Deps != nil {
			if _, err := fmt.Fprintf(w, "    DEPS\n"); err != nil {
				return err
			}
			for _, l := range *t.Deps {
				depName := self.targetName(l)
				if _, err := fmt.Fprintf(w, "        %v\n", depName); err != nil {
					return err
				}
			}
		}

		if _, err := fmt.Fprintf(w, ")\n"); err != nil {
			return err
		}
	case *rules.CcBinaryTarget:
		t := target.(*rules.CcBinaryTarget)

		if _, err := fmt.Fprintf(w, "\n%v(\n", self.CcBinaryName); err != nil {
			return err
		}

		if _, err := fmt.Fprintf(w, "    %v\n",
			self.targetName(target.Label())); err != nil {
			return err
		}

		if t.Srcs != nil {
			if _, err := fmt.Fprintf(w, "    SRCS\n"); err != nil {
				return err
			}
			for _, l := range *t.Srcs {
				// Assume that it's just a simple filename, so just use the target
				// part of the label.
				if _, err := fmt.Fprintf(w, "        %v\n",
					string(l.Target)); err != nil {
					return err
				}
			}
		}

		if t.Deps != nil {
			if _, err := fmt.Fprintf(w, "    DEPS\n"); err != nil {
				return err
			}
			for _, l := range *t.Deps {
				depName := self.targetName(l)
				if _, err := fmt.Fprintf(w, "        %v\n", depName); err != nil {
					return err
				}
			}
		}

		if _, err := fmt.Fprintf(w, ")\n"); err != nil {
			return err
		}
	case *rules.CcTestTarget:
		t := target.(*rules.CcTestTarget)

		if _, err := fmt.Fprintf(w, "\n%v(\n", self.CcTestName); err != nil {
			return err
		}

		if _, err := fmt.Fprintf(w, "    %v\n",
			self.targetName(target.Label())); err != nil {
			return err
		}

		if t.Srcs != nil {
			if _, err := fmt.Fprintf(w, "    SRCS\n"); err != nil {
				return err
			}
			for _, l := range *t.Srcs {
				// Assume that it's just a simple filename, so just use the target
				// part of the label.
				if _, err := fmt.Fprintf(w, "        %v\n",
					string(l.Target)); err != nil {
					return err
				}
			}
		}

		if t.Deps != nil {
			if _, err := fmt.Fprintf(w, "    DEPS\n"); err != nil {
				return err
			}
			for _, l := range *t.Deps {
				depName := self.targetName(l)
				if _, err := fmt.Fprintf(w, "        %v\n", depName); err != nil {
					return err
				}
			}
		}

		if _, err := fmt.Fprintf(w, ")\n"); err != nil {
			return err
		}
	}

	return nil
}

func (self *CmakeConverter) writeNonRootTrailer(packageName core.PackageName, w io.Writer) error {
	// Nothing currently.
	return nil
}

func (self *CmakeConverter) writeNonRootCmakeLists(packageName core.PackageName,
	packageTargets *core.PackageTargets, packagePath string) error {

	outputPath := filepath.Join(packagePath, "CMakeLists.txt")
	f, err := os.OpenFile(outputPath, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, 0644)
	if err != nil {
		return err
	}
	defer f.Close()

	if err := self.writeNonRootHeader(packageName, f); err != nil {
		return err
	}

	for _, target := range packageTargets.TargetList {
		if err := self.writeNonRootBody(target.Label().Target, target, f); err != nil {
			return err
		}
	}

	if err := self.writeNonRootTrailer(packageName, f); err != nil {
		return err
	}

	return nil
}

func (self *CmakeConverter) Convert(outputPath string) error {
	workspaceTargets, ok := self.build.BuildTargets[core.MainWorkspaceName]
	if !ok {
		return fmt.Errorf("no targets in the main workspace")
	}

	for packageName, packageTargets := range workspaceTargets {
		fmt.Printf("Package %v\n", packageName)

		packagePath := filepath.Join(outputPath, string(packageName))
		if err := os.MkdirAll(packagePath, os.ModePerm); err != nil {
			return err
		}

		// TODO(vtl): We should do something else for the "root" package.
		if err := self.writeNonRootCmakeLists(packageName, packageTargets,
			packagePath); err != nil {
			return err
		}
	}

	return nil
}

func main() {
	flag.Parse()

	var workspaceDir string
	args := flag.Args()
	switch {
	case len(args) == 0:
		// The default is to find the workspace root at or above the working directory.
		cwd, err := os.Getwd()
		if err != nil {
			fmt.Printf("ERROR: failed to get working directory: %v\n", err)
			os.Exit(1)
		}
		workspaceDir, _, err = utils.FindWorkspaceDir(cwd)
		if err != nil {
			fmt.Printf("ERROR: failed to find workspace root: %v\n", err)
			os.Exit(1)
		}
	case len(args) == 1:
		workspaceDir = args[0]
	default:
		fmt.Printf("ERROR: usage: %v [workspace-dir]\n", os.Args[0])
		os.Exit(1)
	}

	fmt.Printf("Workspace root: %v\n", workspaceDir)

	bazelIgnore := utils.ReadBazelIgnore(workspaceDir)
	buildFiles, err := utils.FindBuildFiles(workspaceDir, bazelIgnore)
	if err != nil {
		fmt.Printf("ERROR: failed to find BUILD[.bazel] files: %v\n", err)
		os.Exit(1)
	}

	// The "project name" is the name of the directory. This is a bit odd, but Bazel seems to
	// prefer to put things in bazel-<project name>, instead of bazel-<workspace-name>.
	projectName := filepath.Base(workspaceDir)
	if projectName == string(filepath.Separator) {
		fmt.Printf("ERROR: unable to determine project name\n")
		os.Exit(1)
	}
	fmt.Printf("Project name: %v\n", projectName)

	buildFileLabels := make([]core.Label, len(buildFiles))
	for i, buildFile := range buildFiles {
		dir := filepath.Dir(buildFile)
		if dir == "." {
			dir = ""
		}

		buildFileLabels[i] = core.Label{
			Workspace: "",
			Package:   core.PackageName(dir),
			Target:    core.TargetName(filepath.Base(buildFile)),
		}
	}

	build := bazel.NewBuild(bazel.GetSourceFileReader(workspaceDir, projectName))

	err = build.ExecWorkspaceFile()
	if err != nil {
		fmt.Printf("ERROR: failed to execute WORKSPACE file: %v\n", err)
		os.Exit(1)
	}

	workspaceName := string(build.WorkspaceName)
	if workspaceName == "" {
		workspaceName = "<unset>"
	}
	fmt.Printf("Workspace name: %v\n", workspaceName)

	for _, buildFileLabel := range buildFileLabels {
		err := build.ExecBuildFile(buildFileLabel)
		if err != nil {
			fmt.Printf("ERROR: failed to execute BUILD[.bzel] file %v: %v\n",
				buildFileLabel, err)
			os.Exit(1)
		}
	}

	if *onlyPrintTargetsFlag {
		printTargets(build)
		os.Exit(0)
	}

	outDir := workspaceDir
	if *outDirFlag != "" {
		outDir = *outDirFlag
	}

	// TODO(vtl)
	/*
	converter := &CmakeConverter{
		MinimumVersion: "3.10.0",
		ProjectPrefix:  "",  // Use default.
		Includes:       nil, // Use default.
		CcLibraryName:  "",  // Use default.
		CcBinaryName:   "",  // Use default.
		CcTestName:     "",  // Use default.
	}
	*/
	converter := &CmakeConverter{
		MinimumVersion: "3.10.0",
		ProjectPrefix:  "", // Use default.
		Includes:       []string{"TricotCommon"},
		CcLibraryName:  "tricot_cc_library",
		CcBinaryName:   "tricot_cc_binary",
		CcTestName:     "tricot_cc_test",
	}

	err = converter.Init(build)
	if err != nil {
		fmt.Printf("ERROR: failed to initialize converter: %v\n", err)
		os.Exit(1)
	}

	err = converter.Convert(outDir)
	if err != nil {
		fmt.Printf("ERROR: %v\n", err)
		os.Exit(1)
	}
}
